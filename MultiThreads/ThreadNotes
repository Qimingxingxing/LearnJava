http://blog.csdn.net/suifeng3051/article/details/49251959
进程的特点，每一个进程都有自己的独立的一块内存空间、一组资源系统
其内部数据和状态都是完全独立的
进程的优点是提高CPU运行效率，在同一时间内执行多个程序，即并发执行。但是从严格上讲,也不是绝对的同
一时刻执行多个程序，只不过CPU在执行时通过时间片等调度算法不同进程高速切换。总结来说：

进程由操作系统调度，简单而且稳定
进程之间的隔离性好，一个进程崩溃不会影响其它进程
单进程编程简单
在多核情况下可以把进程和CPU进行绑定，充分利用CPU

当然，多进程也有一些缺点：

一般来说进程消耗的内存比较大
进程切换代价很高，进程切换也像线程一样需要保持上一个进程的上下文环境
在web编程中，如果一个进程来处理一个请求的话，如果要提高并发量就要提高进程数，而进程数量受内存和切换代价限制

线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少
的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.

同类的多个线程共享一块内存空间和一组系统资源，线程本身的数据通常只有CPU的寄存器数据，以及一个供程序执行时的堆栈。
线程在切换时负荷小，因此，线程也被称为轻负荷进程。一个进程中可以包含多个线程。
在JVM中，本地方法栈、虚拟机栈和程序计数器是线程隔离的，而堆区和方法区是线程共享的。

进程线程的区别

地址空间：进程内的一个执行单元；进程至少有一个线程；它们共享进程的地址空间;而进程有自己独立的地址空间
资源拥有：进程是资源分配和拥有的单位，同一个进程内的线程共享进程的资源
线程是处理器调度的基本单位，但进程不是
二者均可并发执行

 并发：多个事件在同一时间段内一起执行
 并行：多个事件在同一时刻同时执行

 多线程的调度

 在Java程序中，JVM负责线程的调度。线程调度是值按照特定的机制为多个线程分配CPU的使用权。

 调度的模式有两种：分时调度和抢占式调度。分时调度是所有线程轮流获得CPU使用权，并平均分配每个线程占用CPU的时间；
 抢占式调度是根据线程的优先级别来获取CPU的使用权。JVM的线程调度模式采用了抢占式模式。

 实现Runnable接口比继承Thread类有更多的优势，所以我推荐大家尽量使用实现runnable接口的形式，以下是其优点

 - 适合多个相同的程序代码的线程去处理同一个资源
 - 可以避免java中的单继承的限制
 - 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立。

 线程的五种状态类型

 1. 新建状态（New）：新创建了一个线程对象。
 2. 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
 3. 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
 4. 阻塞状态（Blocked）：塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。
 5. 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

 其中阻塞又可能是由以下几种情况造成：

 调用 sleep(毫秒数)，使线程进入“睡眠”状态。在规定的时间内，这个线程是不会运行的。
 用 suspend()暂停了线程的执行。除非线程收到 resume()消息，否则不会返回“可运行”状态。
 用 wait()暂停了线程的执行。除非线程收到 nofify()或者 notifyAll()消息，否则不会变成“可运行“。
 线程正在等候一些 IO（输入输出）操作完成。
 线程试图调用另一个对象的“同步”方法，但那个对象处于锁定状态，暂时无法使用。

4.1 sleep() 方法

sleep()允许指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，
线程重新进入可执行状态。典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，
直到条件满足为止。

4.2 suspend() 和 resume() 方法

两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新
进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线
程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。

4.3 yield() 方法

yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。
调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。

4.4 wait() 和 notify() 方法

两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许指定以毫秒为单位的一段时间作为参数，另一种没
有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调
用。初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面
叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。

http://blog.csdn.net/suifeng3051/article/details/48711405

Synchronized 关键字

在java中实现资源同步非常简单，只需要用synchronized关键字来标记即可。需要记住的是，在java中，同步加锁的是一个对象或者一个类，而不是代码。在多线程环境中，对象的所有synchronized方法一次只能被一个线程访问，其它所有访问同步块的线程会被一直阻塞直到同步块中的线程退出。

synchronized方法控制对类对象方法的访问，每个类对象都对应一把锁，每个 synchronized 方法都必须获得该方法所属对象的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该对象锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个对象实例，其所有声明为 synchronized 的实例函数中至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突。注意，其它非synchronized的函数仍可被其它线程同时访问。

在 Java 中，不光是类的对象，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 synchronized ，以控制其对类的静态成员变量的访问。

synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率，典型地，若将线程类的方法 run() 声明为synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功，因此， Java 为我们提供了更好的解决办法，那就是 synchronized 代码块。

最后做一下总结

在多线程环境中，可以使用synchronized关键字对资源进行同步
synchronized关键字可以同步方法和代码块
同步的是对象或者类，而不是代码
一个对象中的同步方法一次只能被一个线程访问，如果有多个同步方法，一个线程一次也只能访问其中的一个同步方法，但是非同步方法不受任何影响
同步是通过加锁的形式来控制的，让一个线程访问一个同步方法时会获得这个对象的锁，只有退出同步方法时才会释放这个锁，其它线程才可访问

http://blog.csdn.net/suifeng3051/article/details/51852526
wait(): 调用任何对象的wait()方法会让当前线程进入等待，直到另一个线程调用同一个对象的notify()或notifyAll()方法。
notify():唤醒因调用这个对象wait()方法而阻塞的线程。

http://blog.csdn.net/suifeng3051/article/details/49443835

ExecutorService有如下几个执行方法：

- execute(Runnable)
- submit(Runnable)
- submit(Callable)
- invokeAny(...)
- invokeAll(...)